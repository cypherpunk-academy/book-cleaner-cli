import { v4 as uuidv4 } from "uuid";
import type { Step1_1ExecutionSummary } from "./step_1_File_Format_Detection_And_Validation/ExecutionSummary";
import type { Step1_2ExecutionSummary } from "./step_2_Text_Extraction/ExecutionSummary";
import type { Step1_3ExecutionSummary } from "./step_3_Text_Auto_Correction/ExecutionSummary";
import type { Step1_4ExecutionSummary } from "./step_4_Structure_Normalization/ExecutionSummary";
import type { Step1_5ExecutionSummary } from "./step_5_Convert_Footnotes_To_Endnotes/ExecutionSummary";
import type { Step1_6ExecutionSummary } from "./step_6_OCR_Text_Quality_Enhancement/ExecutionSummary";

/**
 * Phase 1 Execution Summary
 */
export interface Phase1ExecutionSummary {
  phaseName: string;
  phaseId: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  status: "pending" | "running" | "completed" | "failed";
  input: {
    filePath: string;
    fileSize: number;
    expectedFormat: string;
  };
  steps: {
    step1_1?: Step1_1ExecutionSummary;
    step1_2?: Step1_2ExecutionSummary;
    step1_3?: Step1_3ExecutionSummary;
    step1_4?: Step1_4ExecutionSummary;
    step1_5?: Step1_5ExecutionSummary;
    step1_6?: Step1_6ExecutionSummary;
  };
  output?: {
    finalTextLength: number;
    detectedFormat: string;
    extractionSuccess: boolean;
    structureDetected: boolean;
    confidence: number;
  };
  metrics?: {
    totalProcessingTime: number;
    stepsCompleted: number;
    stepsSkipped: number;
    filesGenerated: number;
    successRate: number;
  };
  error?: string;
}

/**
 * Create a new Phase 1 execution summary
 */
export function createPhase1ExecutionSummary(
  filePath: string,
  fileSize: number,
  expectedFormat: string,
): Phase1ExecutionSummary {
  return {
    phaseName: "Text Extraction & Format Processing",
    phaseId: uuidv4(),
    startTime: new Date(),
    status: "pending",
    input: {
      filePath,
      fileSize,
      expectedFormat,
    },
    steps: {},
  };
}

/**
 * Update phase summary with step completion
 */
export function updatePhase1ExecutionSummaryWithStep(
  summary: Phase1ExecutionSummary,
  stepName: "step1_1" | "step1_2" | "step1_3" | "step1_4",
  stepSummary:
    | Step1_1ExecutionSummary
    | Step1_2ExecutionSummary
    | Step1_3ExecutionSummary
    | Step1_4ExecutionSummary,
): Phase1ExecutionSummary {
  return {
    ...summary,
    status: "running",
    steps: {
      ...summary.steps,
      [stepName]: stepSummary,
    },
  };
}

/**
 * Update phase summary with final results
 */
export function updatePhase1ExecutionSummary(
  summary: Phase1ExecutionSummary,
  finalTextLength: number,
  detectedFormat: string,
  extractionSuccess: boolean,
  structureDetected: boolean,
  confidence: number,
): Phase1ExecutionSummary {
  const endTime = new Date();
  const duration = endTime.getTime() - summary.startTime.getTime();

  // Calculate metrics
  const stepsCompleted = Object.values(summary.steps).filter(
    (step) => step?.status === "completed",
  ).length;

  const stepsSkipped = Object.values(summary.steps).filter(
    (step) => step?.status === "pending",
  ).length;

  const filesGenerated = Object.values(summary.steps).reduce((count, step) => {
    if (step?.status === "completed") {
      // Count files generated by each step
      if ("output" in step && step.output && "textFiles" in step.output) {
        return count + (step.output.textFiles as string[]).length;
      }
    }
    return count;
  }, 0);

  const successRate =
    stepsCompleted > 0 ? stepsCompleted / (stepsCompleted + stepsSkipped) : 0;

  return {
    ...summary,
    endTime,
    duration,
    status: "completed",
    output: {
      finalTextLength,
      detectedFormat,
      extractionSuccess,
      structureDetected,
      confidence,
    },
    metrics: {
      totalProcessingTime: duration,
      stepsCompleted,
      stepsSkipped,
      filesGenerated,
      successRate,
    },
  };
}

/**
 * Update phase summary with error
 */
export function updatePhase1ExecutionSummaryWithError(
  summary: Phase1ExecutionSummary,
  error: string,
): Phase1ExecutionSummary {
  const endTime = new Date();
  const duration = endTime.getTime() - summary.startTime.getTime();

  return {
    ...summary,
    endTime,
    duration,
    status: "failed",
    error,
  };
}
